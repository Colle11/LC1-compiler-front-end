-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParBlu where
import AbsBlu
import LexBlu
import ErrM

}

%name pProgram Program
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '$' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '&' { PT _ (TS _ 4) }
  '&&' { PT _ (TS _ 5) }
  '&:=' { PT _ (TS _ 6) }
  '(' { PT _ (TS _ 7) }
  ')' { PT _ (TS _ 8) }
  '*' { PT _ (TS _ 9) }
  '*:=' { PT _ (TS _ 10) }
  '+' { PT _ (TS _ 11) }
  '+:=' { PT _ (TS _ 12) }
  ',' { PT _ (TS _ 13) }
  '-' { PT _ (TS _ 14) }
  '-:=' { PT _ (TS _ 15) }
  '->' { PT _ (TS _ 16) }
  '/' { PT _ (TS _ 17) }
  '/:=' { PT _ (TS _ 18) }
  ':' { PT _ (TS _ 19) }
  ':=' { PT _ (TS _ 20) }
  ';' { PT _ (TS _ 21) }
  '<' { PT _ (TS _ 22) }
  '<=' { PT _ (TS _ 23) }
  '<>' { PT _ (TS _ 24) }
  '=' { PT _ (TS _ 25) }
  '>' { PT _ (TS _ 26) }
  '>=' { PT _ (TS _ 27) }
  'Array' { PT _ (TS _ 28) }
  'Pt' { PT _ (TS _ 29) }
  '[' { PT _ (TS _ 30) }
  ']' { PT _ (TS _ 31) }
  '^:=' { PT _ (TS _ 32) }
  'bool' { PT _ (TS _ 33) }
  'char' { PT _ (TS _ 34) }
  'const' { PT _ (TS _ 35) }
  'do' { PT _ (TS _ 36) }
  'else' { PT _ (TS _ 37) }
  'elseif' { PT _ (TS _ 38) }
  'end' { PT _ (TS _ 39) }
  'for' { PT _ (TS _ 40) }
  'goto' { PT _ (TS _ 42) }
  'if' { PT _ (TS _ 43) }
  'int' { PT _ (TS _ 44) }
  'is' { PT _ (TS _ 45) }
  'label' { PT _ (TS _ 46) }
  'real' { PT _ (TS _ 47) }
  'routines' { PT _ (TS _ 48) }
  'string' { PT _ (TS _ 49) }
  'then' { PT _ (TS _ 50) }
  'valres' { PT _ (TS _ 51) }
  'var' { PT _ (TS _ 52) }
  'while' { PT _ (TS _ 53) }
  '|:=' { PT _ (TS _ 54) }
  '||' { PT _ (TS _ 55) }

L_PIdent { PT _ (T_PIdent _) }
L_PInteger { PT _ (T_PInteger _) }
L_PReal { PT _ (T_PReal _) }
L_PChar { PT _ (T_PChar _) }
L_PString { PT _ (T_PString _) }
L_PBool { PT _ (T_PBool _) }
L_PBreak { PT _ (T_PBreak _) }
L_PContinue { PT _ (T_PContinue _) }
L_PWriteInt { PT _ (T_PWriteInt _) }
L_PWriteFloat { PT _ (T_PWriteFloat _) }
L_PWriteChar { PT _ (T_PWriteChar _) }
L_PWriteString { PT _ (T_PWriteString _) }
L_PReadInt { PT _ (T_PReadInt _) }
L_PReadFloat { PT _ (T_PReadFloat _) }
L_PReadChar { PT _ (T_PReadChar _) }
L_PReadString { PT _ (T_PReadString _) }


%%

PIdent    :: { PIdent} : L_PIdent { PIdent (mkPosToken $1)}
PInteger    :: { PInteger} : L_PInteger { PInteger (mkPosToken $1)}
PReal    :: { PReal} : L_PReal { PReal (mkPosToken $1)}
PChar    :: { PChar} : L_PChar { PChar (mkPosToken $1)}
PString    :: { PString} : L_PString { PString (mkPosToken $1)}
PBool    :: { PBool} : L_PBool { PBool (mkPosToken $1)}
PBreak    :: { PBreak} : L_PBreak { PBreak (mkPosToken $1)}
PContinue    :: { PContinue} : L_PContinue { PContinue (mkPosToken $1)}
PWriteInt    :: { PWriteInt} : L_PWriteInt { PWriteInt (mkPosToken $1)}
PWriteFloat    :: { PWriteFloat} : L_PWriteFloat { PWriteFloat (mkPosToken $1)}
PWriteChar    :: { PWriteChar} : L_PWriteChar { PWriteChar (mkPosToken $1)}
PWriteString    :: { PWriteString} : L_PWriteString { PWriteString (mkPosToken $1)}
PReadInt    :: { PReadInt} : L_PReadInt { PReadInt (mkPosToken $1)}
PReadFloat    :: { PReadFloat} : L_PReadFloat { PReadFloat (mkPosToken $1)}
PReadChar    :: { PReadChar} : L_PReadChar { PReadChar (mkPosToken $1)}
PReadString    :: { PReadString} : L_PReadString { PReadString (mkPosToken $1)}

Program :: { Program }
Program : ConstDecls VarDecls FunDecls { AbsBlu.Prog $1 $2 $3 }
ConstDecls :: { ConstDecls }
ConstDecls : {- empty -} { AbsBlu.ConstEmpty }
           | 'const' ListConstDecl 'end' 'const' { AbsBlu.ConstBlk (reverse $2) }
ListConstDecl :: { [ConstDecl] }
ListConstDecl : {- empty -} { [] }
              | ListConstDecl ConstDecl { flip (:) $1 $2 }
ConstDecl :: { ConstDecl }
ConstDecl : PIdent ':' Type ':=' RExpr ';' { AbsBlu.ConstD (getPIdentPos $1) $1 $3 $5 }
VarDecls :: { VarDecls }
VarDecls : {- empty -} { AbsBlu.VarEmpty }
         | 'var' ListVarDecl 'end' 'var' { AbsBlu.VarBlk (reverse $2) }
ListVarDecl :: { [VarDecl] }
ListVarDecl : {- empty -} { [] }
            | ListVarDecl VarDecl { flip (:) $1 $2 }
VarDecl :: { VarDecl }
VarDecl : PIdent ':' Type MaybeInit ';' { AbsBlu.VarD (getPIdentPos $1) $1 $3 $4 }
MaybeInit :: { MaybeInit }
MaybeInit : {- empty -} { AbsBlu.NoInit }
          | ':=' RExpr { AbsBlu.JustInit (getRExprPos $2) $2 }
FunDecls :: { FunDecls }
FunDecls : {- empty -} { AbsBlu.FunBlkEmpty }
         | 'routines' ListFunDecl 'end' 'routines' { AbsBlu.FunBlk (reverse $2) }
ListFunDecl :: { [FunDecl] }
ListFunDecl : {- empty -} { [] }
            | ListFunDecl FunDecl { flip (:) $1 $2 }
FunDecl :: { FunDecl }
FunDecl : PIdent MaybeParamsIn MaybeParamsOut 'is' FBody 'end' PIdent { AbsBlu.FunD (getPIdentPos $1) $1 $2 $3 $5 $7 }
MaybeParamsIn :: { MaybeParamsIn }
MaybeParamsIn : {- empty -} { AbsBlu.NoParamsIn }
              | '(' ListParamIn ')' { AbsBlu.JustParamsIn $2 }
ListParamIn :: { [ParamIn] }
ListParamIn : {- empty -} { [] }
            | ParamIn { (:[]) $1 }
            | ParamIn ',' ListParamIn { (:) $1 $3 }
ParamIn :: { ParamIn }
ParamIn : Modality PIdent ':' Type { AbsBlu.ParamIn (getPIdentPos $2) $1 $2 $4 }
Modality :: { Modality }
Modality : {- empty -} { AbsBlu.ValMod }
         | 'valres' { AbsBlu.ValResMod }
         | 'const' { AbsBlu.ConstMod }
MaybeParamsOut :: { MaybeParamsOut }
MaybeParamsOut : {- empty -} { AbsBlu.NoParamsOut }
               | '->' '(' ListParamOut ')' { AbsBlu.JustParamsOut $3 }
ListParamOut :: { [ParamOut] }
ListParamOut : {- empty -} { [] }
             | ParamOut { (:[]) $1 }
             | ParamOut ',' ListParamOut { (:) $1 $3 }
ParamOut :: { ParamOut }
ParamOut : PIdent ':' Type { AbsBlu.ParamOut (getPIdentPos $1) $1 $3 }
FBody :: { FBody }
FBody : ConstDecls VarDecls FunDecls 'do' ListStmt { AbsBlu.FunBody $1 $2 $3 (reverse $5) }
ListStmt :: { [Stmt] }
ListStmt : {- empty -} { [] } | ListStmt Stmt { flip (:) $1 $2 }
Stmt :: { Stmt }
Stmt : FunCall ';' { AbsBlu.StmFCall $1 }
     | PBreak ';' { AbsBlu.Break $1 }
     | PContinue ';' { AbsBlu.Continue $1 }
     | 'goto' PIdent ';' { AbsBlu.GoTo $2 }
     | 'label' PIdent ':' { AbsBlu.Label $2 }
     | 'while' '(' RExpr ')' 'do' ListStmt 'end' 'while' { AbsBlu.While $3 (reverse $6) }
     | 'do' ListStmt 'while' '(' RExpr ')' { AbsBlu.DoWhile (reverse $2) $5 }
     | 'for' '(' ForAss ',' RExpr ',' ForAss ')' 'do' ListStmt 'end' 'for' { AbsBlu.For $3 $5 $7 (reverse $10) }
     | 'if' '(' RExpr ')' 'then' ListStmt MaybeElseIf MaybeElse 'end' 'if' { AbsBlu.If $3 (reverse $6) $7 $8 }
     | ListLExpr Ass_Op RExpr ';' { AbsBlu.Assgn $1 $2 $3 }
ListLExpr :: { [LExpr] }
ListLExpr : LExpr { (:[]) $1 }
          | LExpr ',' ListLExpr { (:) $1 $3 }
MaybeElseIf :: { MaybeElseIf }
MaybeElseIf : {- empty -} { AbsBlu.NoElseIf }
            | 'elseif' '(' RExpr ')' 'then' ListStmt MaybeElseIf { AbsBlu.ElseIf $3 (reverse $6) $7 }
MaybeElse :: { MaybeElse }
MaybeElse : {- empty -} { AbsBlu.NoElse }
          | 'else' ListStmt { AbsBlu.Else (reverse $2) }
ForAss :: { ForAss }
ForAss : LExpr Ass_Op RExpr { AbsBlu.ForAssgn $1 $2 $3 }
Ass_Op :: { Ass_Op }
Ass_Op : ':=' { AbsBlu.Assign }
       | '*:=' { AbsBlu.AssignMul }
       | '+:=' { AbsBlu.AssignAdd }
       | '/:=' { AbsBlu.AssignDiv }
       | '-:=' { AbsBlu.AssignSub }
       | '^:=' { AbsBlu.AssignPow }
       | '&:=' { AbsBlu.AssignAnd }
       | '|:=' { AbsBlu.AssignOr }
Type :: { Type }
Type : 'Array' '<' Type '>' '(' MaybeSize ')' { AbsBlu.TArr $3 $6 }
     | 'Pt' '<' Type '>' { AbsBlu.TPt $3 }
     | BasicType { AbsBlu.TBasic $1 }
MaybeSize :: { MaybeSize }
MaybeSize : {- empty -} { AbsBlu.ArrNoSize }
          | RExpr { AbsBlu.ArrSize (getRExprPos $1) $1 }
BasicType :: { BasicType }
BasicType : 'bool' { AbsBlu.TBool }
          | 'char' { AbsBlu.TChar }
          | 'string' { AbsBlu.TString }
          | 'real' { AbsBlu.TReal }
          | 'int' { AbsBlu.TInt }
RExpr :: { RExpr }
RExpr : RExpr1 { $1 }
RExpr1 :: { RExpr }
RExpr1 : RExpr2 { $1 } | RExpr1 '||' RExpr2 { AbsBlu.Or (getRExprPos $1) $1 $3 }
RExpr2 :: { RExpr }
RExpr2 : RExpr3 { $1 } | RExpr2 '&&' RExpr3 { AbsBlu.And (getRExprPos $1) $1 $3 }
RExpr3 :: { RExpr }
RExpr3 : RExpr4 { $1 }
       | RExpr3 '=' RExpr4 { AbsBlu.Eq (getRExprPos $1) $1 $3 }
       | RExpr3 '<>' RExpr4 { AbsBlu.NEq (getRExprPos $1) $1 $3 }
RExpr4 :: { RExpr }
RExpr4 : RExpr5 { $1 }
       | RExpr4 '<' RExpr5 { AbsBlu.Lt (getRExprPos $1) $1 $3 }
       | RExpr4 '<=' RExpr5 { AbsBlu.LEq (getRExprPos $1) $1 $3 }
       | RExpr4 '>' RExpr5 { AbsBlu.Gt (getRExprPos $1) $1 $3 }
       | RExpr4 '>=' RExpr5 { AbsBlu.GEq (getRExprPos $1) $1 $3 }
RExpr5 :: { RExpr }
RExpr5 : RExpr6 { $1 }
       | RExpr5 '+' RExpr6 { AbsBlu.Add (getRExprPos $1) $1 $3 }
       | RExpr5 '-' RExpr6 { AbsBlu.Sub (getRExprPos $1) $1 $3 }
RExpr6 :: { RExpr }
RExpr6 : RExpr7 { $1 }
       | RExpr6 '*' RExpr7 { AbsBlu.Mul (getRExprPos $1) $1 $3 }
       | RExpr6 '/' RExpr7 { AbsBlu.Div (getRExprPos $1) $1 $3 }
       | RExpr6 '%' RExpr7 { AbsBlu.Mod (getRExprPos $1) $1 $3 }
RExpr7 :: { RExpr }
RExpr7 : RExpr8 { $1 }
       | FunCall { AbsBlu.RexprCall (getFunCallPos $1) $1 }
       | '[' ListRExpr ']' { AbsBlu.ArrayElems $2 }
       | '&' LExpr { AbsBlu.AddrOf (getLExprPos $2) $2 }
       | '!' RExpr7 { AbsBlu.Not (getRExprPos $2) $2 }
       | '-' RExpr7 { AbsBlu.UnMin (getRExprPos $2) $2 }
       | '+' RExpr7 { AbsBlu.UnPlus (getRExprPos $2) $2 }
RExpr8 :: { RExpr }
RExpr8 : '(' RExpr ')' { $2 }
       | LExpr { AbsBlu.Lexpr (getLExprPos $1) $1 }
       | PInteger { AbsBlu.Integer (getPIntegerPos $1) $1 }
       | PReal { AbsBlu.Real (getPRealPos $1) $1 }
       | PChar { AbsBlu.Char (getPCharPos $1) $1 }
       | PString { AbsBlu.String (getPStringPos $1) $1 }
       | PBool { AbsBlu.Bool (getPBoolPos $1) $1 }
ListRExpr :: { [RExpr] }
ListRExpr : {- empty -} { [] }
          | RExpr { (:[]) $1 }
          | RExpr ',' ListRExpr { (:) $1 $3 }
FunCall :: { FunCall }
FunCall : PIdent '(' ListRExpr ')' { AbsBlu.UserDefFCall $1 $3 }
        | PWriteInt '(' RExpr ')' { AbsBlu.WIntCall $1 $3 }
        | PWriteFloat '(' RExpr ')' { AbsBlu.WFloatCall $1 $3 }
        | PWriteChar '(' RExpr ')' { AbsBlu.WCharCall $1 $3 }
        | PWriteString '(' RExpr ')' { AbsBlu.WStringCall $1 $3 }
        | PReadInt '(' ')' { AbsBlu.RIntCall $1 }
        | PReadFloat '(' ')' { AbsBlu.RFloatCall $1 }
        | PReadChar '(' ')' { AbsBlu.RCharCall $1 }
        | PReadString '(' ')' { AbsBlu.RStringCall $1 }
LExpr :: { LExpr }
LExpr : LExpr1 { $1 } | '$' RExpr7 { AbsBlu.Deref (getRExprPos $2) $2 }
LExpr1 :: { LExpr }
LExpr1 : LExpr2 { $1 }
       | LExpr1 '[' RExpr ']' { AbsBlu.ElemAt (getLExprPos $1) $1 $3 }
LExpr2 :: { LExpr }
LExpr2 : '(' LExpr ')' { $2 } | PIdent { AbsBlu.Var (getPIdentPos $1) $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens

getPIdentPos :: PIdent -> (Int,Int)
getPIdentPos (PIdent (pos, _)) = pos

getRExprPos :: RExpr -> (Int,Int)
getRExprPos (Or pos _ _) = pos
getRExprPos (And pos _ _) = pos
getRExprPos (Eq pos _ _) = pos
getRExprPos (NEq pos _ _) = pos
getRExprPos (Lt pos _ _) = pos
getRExprPos (LEq pos _ _) = pos
getRExprPos (Gt pos _ _) = pos
getRExprPos (GEq pos _ _) = pos
getRExprPos (Add pos _ _) = pos
getRExprPos (Sub pos _ _) = pos
getRExprPos (Mul pos _ _) = pos
getRExprPos (Div pos _ _) = pos
getRExprPos (Mod pos _ _) = pos
getRExprPos (RexprCall pos _) = pos
getRExprPos (ArrayElems rExprsList) =  case rExprsList of
                                          [] -> (0,0)
                                          (x:xs) -> getRExprPos x
getRExprPos (AddrOf pos _) = pos
getRExprPos (Not pos _) = pos
getRExprPos (UnMin pos _) = pos
getRExprPos (UnPlus pos _) = pos
getRExprPos (Lexpr pos _) = pos
getRExprPos (Integer pos _) = pos
getRExprPos (Real pos _) = pos
getRExprPos (Char pos _) = pos
getRExprPos (String pos _) = pos
getRExprPos (Bool pos _ ) = pos

getPIntegerPos :: PInteger -> (Int,Int)
getPIntegerPos (PInteger (pos, _)) = pos

getPRealPos :: PReal -> (Int,Int)
getPRealPos (PReal (pos, _)) = pos

getPCharPos :: PChar -> (Int,Int)
getPCharPos (PChar (pos, _)) = pos

getPStringPos :: PString -> (Int,Int)
getPStringPos (PString (pos, _)) = pos

getPBoolPos :: PBool -> (Int,Int)
getPBoolPos (PBool (pos, _)) = pos

getLExprPos :: LExpr -> (Int, Int)
getLExprPos (Deref pos _) = pos
getLExprPos (ElemAt pos _ _) = pos
getLExprPos (Var pos _) = pos

getFunCallPos :: FunCall -> (Int,Int)
getFunCallPos (UserDefFCall (PIdent (pos,_)) _) = pos
getFunCallPos (WIntCall (PWriteInt (pos,_)) _) = pos
getFunCallPos (WFloatCall (PWriteFloat (pos,_)) _) = pos
getFunCallPos (WCharCall (PWriteChar (pos,_)) _) = pos
getFunCallPos (WStringCall (PWriteString (pos,_)) _) = pos
getFunCallPos (RIntCall (PReadInt (pos,_)) ) = pos
getFunCallPos (RFloatCall (PReadFloat (pos,_)) ) = pos
getFunCallPos (RCharCall (PReadChar (pos,_)) ) = pos
getFunCallPos (RStringCall (PReadString (pos,_)) ) = pos
}
